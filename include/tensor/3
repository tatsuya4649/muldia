// <tensor/_iter.h> header that declares and defines the container in the _tensor class,
// which is the basis of the tensor class.
//
//
//

#ifndef TENSOR_CONT_H
#define TENSOR_ITER_H

#include <name.h>
#include <tensor/name.h>
#include <memory>
#include <type_traits>
#include <iterator>
#include <tensor/_tensor.h>

namespace _md{
	namespace _ten{
		template<typename T,dim_t I=1,typename Allocator = std::allocator<T>>
		class _tensor_iter{
			//
			// base class of _tensor ( <tensor/_tensor.h> )
			// * methods,classes,variables,and using for tensor iterator
			//
			protected:
				static_assert(std::is_same<T,typename Allocator::value_type>::value,"allocater value type is not matched tensor value type 'T' in tensor/_iter.h");
				
				class _iterator{
					public:
					using traits = std::allocator_traits<Allocator>;
					using difference_type = int;
					using value_type = T;
					using reference = T&;
					using pointer = typename traits::pointer; 
					using iterator_category = std::random_access_iterator_tag;
					using _tensor = _tensor<T,I,Allocator>;
					private:
					T* _p;
					public:
					//------------------------------------------------------
					//		 	constructor
					//------------------------------------------------------
					_iterator()noexcept : _p{nullptr}{}
					_iterator(_tensor<T,I,Allocator>* base_,difference_type index_)noexcept : _p{base_->_ptr + index_}{}
					_iterator(const _iterator& i_) : _p{i_._p} {}
					//------------------------------------------------------
					//			operater
					//------------------------------------------------------
					_iterator& operator++(){
						++_p;
						return *this;
					}
					_iterator operator++(int){
						_iterator res = *this;
						++_p;
						return res;
					}
					_iterator operator+(const difference_type& x_) const{
						return _iterator(*this) += x_;
					}
					_iterator& operator+=(const difference_type& x_) const{
						_p += x_;
						return *this;
					}
					_iterator& operator--(){
						--_p;
						return *this;
					}
					_iterator operator--(int){
						_iterator res = *this;
						--_p;
						return res;
					}
					_iterator operator-(const difference_type& x_) const{
						return _iterator(*this) -= x_;
					}
					difference_type operator-(const _iterator& i_) const{
						return _p - i_._p;
					}
					_iterator& operator-=(const difference_type& x_) {
						_p -= x_;
						return *this;
					}
					reference operator*() const{
						return *_p;
					}
					reference operator[](const difference_type& x_) const{
						return *(*this + x_);
					}
					bool operator<(const _iterator& i_) const{
						return _p < i_._p;
					}
					bool operator<=(const _iterator& i_) const{
						return _p <= i_._p;
					}
					bool operator==(const _iterator& i_) const{
						return _p == i_._p;
					}
					bool operator>(const _iterator& i_) const{
						return _p > i_._p;
					}
					bool operator>=(const _iterator& i_) const{
						return _p >= i_._p;
					}
					bool operator!=(const _iterator& i_) const{
						return _p != i_._p;
					}
				}; // class iterator

				class _const_iterator{
					public:
					using traits = std::allocator_traits<Allocator>;
					using difference_type = int;
					using value_type = T;
					using reference = T&;
					using pointer = typename traits::pointer; 
					using iterator_category = std::random_access_iterator_tag;
					private:
					const T* _p;
					public:
					_const_iterator() noexcept : _p{nullptr} {}
					_const_iterator(_tensor* base_,difference_type index_) noexcept:_p{base_->_ptr+index_}{}
					_const_iterator(const _iterator& i_) : _p{i_._p} {}
					_const_iterator& operator++(){
						++_p;
						return *this;
					}
					_const_iterator operator++(int){
						_const_iterator res = *this;
						++_p;
						return res;
					}
					_const_iterator operator+(const difference_type& x_) const{
						return _const_iterator(*this) += x_;
					}
					_const_iterator operator+=(const difference_type& x_) {
						_p += x_;
						return *this;
					}
					_const_iterator& operator--(){
						--_p;
						return *this;
					}
					_const_iterator operator--(int){
						_const_iterator res = *this;
						--_p;
						return res;
					}
					_const_iterator operator-(const difference_type& x_) const{
						return _const_iterator(*this) -= x_;
					}
					_const_iterator& operator-=(const difference_type& x_) const{
						_p -= x_;
						return *this;
					}
					reference operator*() const{
						return *_p;
					}
					reference operator[](const difference_type& x_) const{
						return *(*this+x_);
					}
					bool operator<(const _const_iterator& i_) const{
						return _p < i_._p;
					}
					bool operator<=(const _const_iterator& i_) const{
						return _p <= i_._p;
					}
					bool operator==(const _const_iterator& i_) const{
						return _p == i_._p;
					}
					bool operator>(const _const_iterator& i_) const{
						return _p > i_._p;
					}
					bool operator>=(const _const_iterator& i_) const{
						return _p >= i_._p;
					}
					bool operator!=(const _const_iterator& i_) const{
						return _p != i_._p;
					}
				}; // class _const_iterator
				using reverse_iterator = std::reverse_iterator<_iterator>;
				using const_reverse_iterator = std::reverse_iterator<_const_iterator>;

				_iterator begin() noexcept{
					return _iterator(this,0);
				}
				_const_iterator begin() const noexcept{
					return _const_iterator(this,0);
				}
				_const_iterator cbegin() const noexcept{
					return _const_iterator(this,0);
				}
				_iterator rbegin() noexcept{
					return reverse_iterator(this,0);
				}
				_const_iterator rbegin() const noexcept{
					return const_reverse_iterator(this,0);
				}
				_const_iterator crbegin() const noexcept{
					return const_reverse_iterator(this,0);
				}
				_iterator end() noexcept  = 0;
				_const_iterator end() const noexcept = 0;
				_const_iterator cend() const noexcept = 0;
				_iterator rend() noexcept = 0;
				_const_iterator rend() const noexcept = 0;
				_const_iterator crend() const noexcept = 0;
		}; // class _tensor_iter
	} // namespace _ten
} // namespace _md

#endif // TENSOR_ITER_H

